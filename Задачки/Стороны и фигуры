struct Puzzle {
    descr: string,
    input: Canvas,
    output: string,
    wrong_output: string,
    explanation: string
}

function gen_puzzle(level: int) -> Puzzle {
    if (level > 20) { level = 20; }
    let counts = [0,0];
    let c = new Canvas{};
    let coordinates = [[50,50],[50,80],[50,110],[50,140],[50,170],[50,200],[50,225],[50,250],
                       [80,50],[80,80],[80,110],[80,140],[80,170],[80,200],[80,225],[80,250],
                       [110,50],[110,80],[110,110],[110,140],[110,170],[110,200],[110,225],[110,250],
                       [140,50],[140,80],[140,110],[140,140],[140,170],[140,200],[140,225],[140,250],
                       [170,50],[170,80],[170,110],[170,140],[170,170],[170,200],[170,225],[170,250],
                       [200,50],[200,80],[200,110],[200,140],[200,170],[200,200],[200,225],[200,250],
                       [230,50],[230,80],[230,110],[230,230],[230,170],[230,200],[230,225],[230,250],
                       [260,50],[260,80],[260,110],[260,140],[260,170],[260,200],[260,225],[260,250],
                       [290,50],[290,80],[290,110],[290,140],[290,170],[290,200],[290,225],[290,250],
                       [320,50],[320,80],[320,110],[320,140],[320,170],[320,200],[320,225],[320,250],
                       [350,50],[350,80],[350,110],[350,140],[350,170],[350,200],[350,225],[350,250]];
    let map: {int: int} = {};
    c.init(400, 300, rgba(rand_int(256), rand_int(256), rand_int(256), 1.0)); 
    for (let i = 0; i < level + 1; i += 1) {
        let xy = rand_int(coordinates.length());
        while (map.contains(xy) && xy < coordinates.length() - 1) {
            xy += 1;
        }
        while (map.contains(xy) && xy > 0) {
            xy -= 1;
        }
        let x = coordinates[xy][0];
        let y = coordinates[xy][1]; 
        map[xy] = xy;
        let figure = random_figure();
        let bg = random_color();
        if (rand_bool()) { bg.a = 0.5; }
        let size = rand_int(10) + 10;
        draw_figure(c, x, y, figure, size, random_color(), bg, counts, map);
    }
    let output = string(counts[0] * counts[1]);
    let wrong_output = string([counts[0] * counts[1] + 1, counts[0] * counts[1] - 1][rand_int(2)]);
    let header = gen_header();
    let task = gen_task();
    let descr = header + "некоторое количество фигур. " + task + "результат произведения количества фигур и общего количества сторон у фигур. " +
        "Если у квадрата имеется 4 стороны, у прямоугольника 4 стороны, круг имеет 2 стороны, треугольник 3 стороны, а пятиугольник 5 сторон.";
    let explanation = "Для того чтобы посчитать произведение количества фигур и общего количества сторон у фигур. Необходимо посчитать сначала количество фигур, затем посчитать количество сторон " +
        "каждой фигуры и сумму сторон всех фигур сложить. Например в данном случае у нас количество фигур равно " + string(counts[0]) + ", а количество сторон равно " + 
        string(counts[1]) + ". Умножаем " + string(counts[0]) + " на " + string(counts[1]) + " в итоге получим " + output + ".";
    
    return new Puzzle {
        descr: descr,
        input: c,
        output: output,
        wrong_output: wrong_output,
        explanation: explanation
    };
}

function random_figure() -> string { return ["square", "circle", "triangle", "rectangle", "pentagon"][rand_int(5)] }
function random_color() -> Color { return rgb(rand_int(256), rand_int(256), rand_int(256)); }

function draw_figure(c: Canvas, x: int, y: int, figure: string, size: int, fg: Color, bg: Color, counts: int[], map: {int: int}) {
    let other_size = size * 2;
    if (rand_bool()) { other_size = size / 2; }
    
    let line = rand_int(3) + 1;
    if (figure == "square") {
        let points: Point2D[] = [];
        let ang = float(rand_int(360)) * 3.1415926 / 180.0;
        for (let i = 0; i < 4; i += 1) {
            ang += 90.0 * 3.1415926 / 180.0;
            points.push(new Point2D{x: float(x) + float(size) * cos(ang), y: float(y) + float(size) * sin(ang)});
        }
        c.fill_polygon(points, fg, bg, line);
        counts[0] += 1;
        counts[1] += 4;
    }
    if (figure == "rectangle") {
        let points: Point2D[] = [];
        let ang = float(rand_int(360)) * 3.1415926 / 180.0;
        let da = float((rand_int(30) + 30)) * 3.1415926 / 180.0;
        for (let i = 0; i < 4; i += 1) {
            ang += 90.0 * 3.1415926 / 180.0;
            if (i == 1 || i == 3) { ang -= da; }
            else { ang += da }
            points.push(new Point2D{x: float(x) + float(size) * cos(ang), y: float(y) + float(size) * sin(ang)});
        }
        c.fill_polygon(points, fg, bg, line);
        counts[0] += 1;
        counts[1] += 4;
    }
    if (figure == "circle") {
        c.fill_ellipse(x - size, y - size, size * 2, size * 2, fg, bg, line);
        counts[0] += 1;
        counts[1] += 2;
    }
    if (figure == "triangle" || figure == "equilateral triangle" || figure == "isosceles triangle" || figure == "right triangle") {
        let rand_kind = rand_int(4);
        let points: Point2D[] = [];
        let ang0 = float(rand_int(360)) * 3.1415926 / 180.0;
        let angs: float[] = [];
        if (figure == "equilateral triangle" || figure == "triangle" && rand_kind == 0) {
            angs = [ang0, ang0 + 120.0 * 3.1415926 / 180.0, ang0 + 240.0 * 3.1415926 / 180.0]
        } else if (figure == "isosceles triangle" || figure == "triangle" && rand_kind == 1) {
            let dang = float(rand_int(21) + 20);
            if (rand_bool()) { dang = float(rand_int(21) + 80); }
           	angs = [ang0, ang0 + (180.0 - dang) * 3.1415926 / 180.0, ang0 + (180.0 + dang) * 3.1415926 / 180.0]
        } else if (figure == "right triangle" || figure == "triangle" && rand_kind == 2) {
            let dang = float(rand_int(121) + 30);
           	angs = [ang0, ang0 + dang * 3.1415926 / 180.0, ang0 + (180.0 + dang) * 3.1415926 / 180.0]
        } else {
            let a1 = float(rand_int(21) + 4);
            let a2 = float(rand_int(21) + 4);
            let sum = float(rand_int(21) + 4) + a1 + a2;
            angs.push(ang0);
            ang0 += 2.0 * 3.1415926 * a1 / sum;
            angs.push(ang0);
            ang0 += 2.0 * 3.1415926 * a2 / sum;
            angs.push(ang0);
        }
        for (let i = 0; i < 3; i += 1) {
            points.push(new Point2D{x: float(x) + float(size) * cos(angs[i]), y: float(y) + float(size) * sin(angs[i])});
        }
        c.fill_polygon(points, fg, bg, line);
        counts[0] += 1;
        counts[1] += 3;
    } else if (figure == "pentagon") {
        let points: Point2D[] = [];
        let ang = float(rand_int(360)) * 3.1415926 / 180.0;
        for (let i = 0; i < 5; i += 1) {
            ang += 72.0 * 3.1415926 / 180.0;
            points.push(new Point2D{x: float(x) + float(size) * cos(ang), y: float(y) + float(size) * sin(ang)});
        }
        c.fill_polygon(points, fg, bg, line);
        counts[0] += 1;
        counts[1] += 5;
    }
} 

function gen_task() -> string {
    let tasks = ["Найти ","Вычислить ","Запишите ","Укажите ","Определите ","Вычислите ","Выясните ","Указать ","Записать ","Определить "];
    return tasks[rand_int(tasks.length())];
}

function gen_header() -> string {
    let headers = ["Дано  ",
                   "Представлено ",
                   "Вы видите ",
                   "Перед вами ",
                   "Нарисовано ",  
                   "Изображено "
    ];
    return headers[rand_int(headers.length())];
}
